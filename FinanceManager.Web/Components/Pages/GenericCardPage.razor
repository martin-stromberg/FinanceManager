@typeparam TKeyValue
@using FinanceManager.Web.ViewModels.Common
@using FinanceManager.Web.Components.Shared
@inject IJSRuntime JS
@using Microsoft.AspNetCore.Components.Forms
@inject FinanceManager.Shared.IApiClient Api
@using FinanceManager.Domain.Attachments
@using static FinanceManager.Web.ViewModels.Common.BaseViewModel

@if (Provider == null)
{
    <p style="opacity:.7;">No provider</p>
}
else
{
    <Ribbon TTabEnum="TabId" Provider="Provider" Localizer="Localizer" />

    @if (!string.IsNullOrEmpty(Provider.LastError))
    {
        <div class="error-msg" style="color:#e66;margin:.5rem 0;padding:.5rem;border:1px solid rgba(230,102,102,.2);background:rgba(230,102,102,.04);border-radius:4px;">@Provider.LastError</div>
    }

    @if (Provider.Loading)
    {
        <p>@LoadingText</p>
    }
    else if (Provider.CardRecord is not null)
    {
        <div class="card-view" style="margin-top:1.25rem;width:100%;">
            <table class="fm-table card" style="width:100%;">
                <tbody>
                    @foreach (var f in Provider.CardRecord.Fields)
                    {
                        <tr>
                            <th style="width:30%;text-align:left;vertical-align:top;padding:.5rem .6rem;font-weight:600;">@(Localizer?[f.LabelKey] ?? f.LabelKey)</th>
                            <td style="padding:.5rem .6rem;">@RenderEditableField(f)</td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    }
}

@code {
    public enum TabId { Card }

    [Parameter] public BaseCardViewModel<TKeyValue>? Provider { get; set; }
    [Parameter] public Microsoft.Extensions.Localization.IStringLocalizer? Localizer { get; set; }

    [Parameter] public string LoadingText { get; set; } = "Loading";

    private readonly Dictionary<string, List<LookupItem>> _enumOptions = new();

    private string GetKey(TKeyValue kv)
    {
        // Default: if kv is (string Key, string Value)
        if (kv is System.ValueTuple<string, string> t)
        {
            return t.Item1;
        }
        // fallback to ToString
        return kv?.ToString() ?? string.Empty;
    }

    private string GetValue(TKeyValue kv)
    {
        if (kv is System.ValueTuple<string, string> t)
        {
            return System.Net.WebUtility.HtmlEncode(t.Item2 ?? string.Empty);
        }
        return System.Net.WebUtility.HtmlEncode(kv?.ToString() ?? string.Empty);
    }

    private RenderFragment RenderField(CardField f) => builder =>
    {
        switch (f.Kind)
        {
            case CardFieldKind.Text:
                // If Text is empty (e.g. lookup without resolved name), fall back to ValueId or a placeholder
                var raw = !string.IsNullOrWhiteSpace(f.Text) ? f.Text : (f.ValueId?.ToString() ?? string.Empty);
                var txt = LocalizeInline(raw);
                builder.AddContent(0, txt);
                break;
            case CardFieldKind.Symbol:
                if (f.SymbolId.HasValue)
                {
                    builder.OpenElement(1, "img");
                    builder.AddAttribute(2, "src", $"/api/attachments/{f.SymbolId}/download");
                    builder.AddAttribute(3, "style", "width:36px;height:36px;object-fit:contain;border-radius:6px;border:1px solid var(--border);");
                    builder.CloseElement();
                }
                break;
            case CardFieldKind.Currency:
                builder.AddContent(4, (f.Amount ?? 0m).ToString("C", System.Globalization.CultureInfo.CurrentCulture));
                break;
        }
    };

    // If field is editable or a lookup, render appropriate input controls instead of plain text
    private RenderFragment RenderEditableField(CardField f) => builder =>
    {
        if (!f.Editable)
        {
            // invoke the RenderFragment returned by RenderField
            builder.AddContent(0, RenderField(f));
            return;
        }

        // Enum-backed fields: render select populated from Provider.QueryLookupAsync results
        if (!string.IsNullOrEmpty(f.LookupType) && f.LookupType.StartsWith("Enum:", StringComparison.OrdinalIgnoreCase))
        {
            // Try to get cached options for this lookupType
            if (!_enumOptions.TryGetValue(f.LookupType, out var opts) || opts == null)
            {
                // show disabled select while loading
                builder.OpenElement(0, "select");
                builder.AddAttribute(1, "class", "card-input");
                builder.AddAttribute(2, "disabled", true);
                var loadingLabel = Localizer != null ? Localizer["Loading"].Value : "Loading";
                builder.OpenElement(3, "option"); builder.AddContent(4, loadingLabel); builder.CloseElement();
                builder.CloseElement();
                return;
            }

            builder.OpenElement(10, "select");
            builder.AddAttribute(11, "class", "card-input");
            builder.AddAttribute(12, "value", f.Text ?? string.Empty);
            builder.AddAttribute(13, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(this, (ChangeEventArgs e) => OnEnumChanged(f, e)));

            foreach (var li in opts)
            {
                builder.OpenElement(20, "option");
                builder.AddAttribute(21, "value", li.Name);
                if (string.Equals(f.Text, li.Name, StringComparison.OrdinalIgnoreCase)) builder.AddAttribute(22, "selected", true);
                builder.AddContent(23, li.Name);
                builder.CloseElement();
            }

            builder.CloseElement();
            return;
        }

        // Lookup fields: render special input with suggestions
        if (!string.IsNullOrEmpty(f.LookupType))
        {
            // wrapper for relative positioning
            builder.OpenElement(0, "div");
            builder.AddAttribute(1, "style", "position:relative;display:inline-block;width:100%;");

            // input
            builder.OpenElement(2, "input");
            builder.AddAttribute(3, "value", f.Text ?? string.Empty);
            builder.AddAttribute(4, "class", "card-input");
            builder.AddAttribute(5, "oninput", EventCallback.Factory.Create<ChangeEventArgs>(this, (ChangeEventArgs e) => OnLookupInputAsync(f, e)));
            builder.AddAttribute(6, "onfocus", EventCallback.Factory.Create(this, () => _openLookupField = f));
            builder.AddAttribute(7, "onfocusout", EventCallback.Factory.Create(this, () => CloseLookup(f)));
            builder.AddAttribute(8, "onchange", EventCallback.Factory.Create<ChangeEventArgs>(this, (ChangeEventArgs e) => OnLookupChangeCommit(f, e)));
            builder.CloseElement();

            // overlay panel
            if (_openLookupField == f && _lookupResults.TryGetValue(f, out var list) && list?.Count > 0)
            {
                builder.OpenElement(20, "div");
                builder.AddAttribute(21, "class", "lookup-overlay");
                builder.AddAttribute(22, "style", "position:absolute;left:0;right:0;z-index:20;background:var(--panel-bg);border:1px solid var(--border);max-height:200px;overflow:auto;margin-top:.25rem;border-radius:4px;padding:.25rem;");
                int seq = 23;
                foreach (var item in list)
                {
                    builder.OpenElement(seq++, "div");
                    builder.AddAttribute(seq++, "class", "lookup-item");
                    builder.AddAttribute(seq++, "style", "padding:.3rem .5rem;cursor:pointer;");
                    var id = item.Key; var name = item.Name;
                    // use pointerdown so selection happens before input loses focus (blur), preventing overlay from being closed prematurely
                    builder.AddAttribute(seq++, "onpointerdown", EventCallback.Factory.Create<Microsoft.AspNetCore.Components.Web.PointerEventArgs>(this, (Microsoft.AspNetCore.Components.Web.PointerEventArgs _) => OnSelectLookupAsync(f, id, name)));
                    builder.AddContent(seq++, name);
                    builder.CloseElement();
                }
                builder.CloseElement();
            }

            builder.CloseElement(); // wrapper
            return;
        }

        switch (f.Kind)
        {
            case CardFieldKind.Text:
                builder.OpenElement(0, "input");
                builder.AddAttribute(1, "value", f.Text ?? string.Empty);
                builder.AddAttribute(2, "class", "card-input");
                builder.AddAttribute(3, "oninput", EventCallback.Factory.Create<ChangeEventArgs>(this, (ChangeEventArgs e) => OnEditableTextChanged(f, e)));
                builder.CloseElement();
                break;
            case CardFieldKind.Symbol:
                // Render preview inside a fixed-size box and place upload control next to it so both are vertically aligned
                builder.OpenElement(0, "div");
                builder.AddAttribute(1, "style", "display:flex;align-items:center;gap:.5rem;");

                // image box
                builder.OpenElement(2, "div");
                builder.AddAttribute(3, "style", "width:36px;height:36px;border:1px solid var(--border);display:flex;align-items:center;justify-content:center;overflow:hidden;border-radius:6px;");
                if (f.SymbolId.HasValue)
                {
                    builder.OpenElement(4, "img");
                    builder.AddAttribute(5, "src", $"/api/attachments/{f.SymbolId}/download");
                    builder.AddAttribute(6, "alt", "symbol");
                    builder.AddAttribute(7, "style", "max-width:100%;max-height:100%;display:block;");
                    builder.CloseElement();
                }
                else
                {
                    builder.AddMarkupContent(8, "<div style=\"width:100%;height:100%;display:flex;align-items:center;justify-content:center;color:var(--muted);\"><svg style=\"width:18px;height:18px;opacity:.6;\"><use href=\"/icons/sprite.svg#image\" /></svg></div>");
                }
                builder.CloseElement();

                // file input (styled button provided by CSS class)
                builder.OpenComponent<InputFile>(9);
                builder.AddAttribute(10, "OnChange", EventCallback.Factory.Create<InputFileChangeEventArgs>(this, (e) => OnInputFileChangeAsync(e, f)));
                builder.AddAttribute(11, "accept", "image/*");
                builder.AddAttribute(12, "class", "card-input-file");
                builder.CloseComponent();

                builder.CloseElement();
                break;
            case CardFieldKind.Currency:
                builder.OpenElement(9, "input");
                builder.AddAttribute(10, "value", (f.Amount ?? 0m).ToString(System.Globalization.CultureInfo.CurrentCulture));
                builder.AddAttribute(11, "class", "card-input numeric");
                builder.AddAttribute(12, "oninput", EventCallback.Factory.Create<ChangeEventArgs>(this, (ChangeEventArgs e) => OnEditableCurrencyChanged(f, e)));
                builder.CloseElement();
                break;
        }
    };

    private string LocalizeInline(string input)
    {
        if (string.IsNullOrEmpty(input)) return string.Empty;
        if (Localizer == null) return input;
        return System.Text.RegularExpressions.Regex.Replace(input, "\\$(\\w+)", m =>
        {
            var key = m.Groups[1].Value;
            var ls = Localizer[key];
            return ls.ResourceNotFound ? m.Value : ls.Value;
        });
    }

    private async Task OnInputFileChangeAsync(InputFileChangeEventArgs e, CardField f)
    {
        try
        {
            var file = e.File;
            if (file == null) return;
            // determine entity kind and id from Provider.CardRecord.Item if possible
            if (Provider?.CardRecord?.Item is FinanceManager.Shared.Dtos.Accounts.AccountDto acc)
            {
                // upload as Attachment for Account
                using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB
                var vm = Provider as BaseCardViewModel<TKeyValue>;
                var newId = await vm?.ValidateSymbolAsync(stream, file.Name, file.ContentType ?? "application/octet-stream");
                if (newId.HasValue)
                {
                    f.SymbolId = newId.Value;
                    await InvokeAsync(StateHasChanged);
                }
            }
            else if (Provider?.CardRecord?.Item is FinanceManager.Shared.Dtos.Contacts.ContactDto c)
            {
                using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024);
                var vm = Provider as BaseCardViewModel<TKeyValue>;
                var newId = await vm?.ValidateSymbolAsync(stream, file.Name, file.ContentType ?? "application/octet-stream");
                if (newId.HasValue)
                {
                    f.SymbolId = newId.Value;
                    await InvokeAsync(StateHasChanged);
                }
            }
            else
            {
                // unknown owner: attempt upload to Attachments root not supported; ignore
            }
        }
        catch (Exception ex)
        {
            // TODO: surface error to user (toast) — for now just debug
            System.Diagnostics.Debug.WriteLine(ex);
        }
    }

    private readonly Dictionary<CardField, List<LookupItem>> _lookupResults = new();
    private CardField? _openLookupField;
    private BaseCardViewModel<TKeyValue>? _subscribedProvider;

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        if (_subscribedProvider != Provider)
        {
            if (_subscribedProvider != null) _subscribedProvider.StateChanged -= OnProviderStateChanged;
            _subscribedProvider = Provider;
            if (_subscribedProvider != null) _subscribedProvider.StateChanged += OnProviderStateChanged;
        }

        // preload enum options provided by the ViewModel
        _enumOptions.Clear();
        if (Provider?.CardRecord?.Fields != null)
        {
            var enumLookupTypes = Provider.CardRecord.Fields
                .Where(f => !string.IsNullOrWhiteSpace(f.LookupType) && f.LookupType.StartsWith("Enum:", StringComparison.OrdinalIgnoreCase))
                .Select(f => f.LookupType)
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            foreach (var lt in enumLookupTypes)
            {
                try
                {
                    var items = await Provider.QueryLookupAsync(new CardField("", CardFieldKind.Text, lookupType: lt), null, 0, 200);
                    _enumOptions[lt] = items?.ToList() ?? new List<LookupItem>();
                }
                catch { _enumOptions[lt] = new List<LookupItem>(); }
            }
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        // keep legacy subscription logic for synchronous parameter changes
    }

    private void OnProviderStateChanged(object? _, EventArgs __) => InvokeAsync(StateHasChanged);

    public void Dispose()
    {
        if (_subscribedProvider != null) _subscribedProvider.StateChanged -= OnProviderStateChanged;
    }

    private async Task OnLookupInputAsync(CardField f, ChangeEventArgs e)
    {
        try
        {
            var q = (e.Value ?? string.Empty).ToString();
            f.Text = q;
            if (Provider is not null)
            {
                var list = await Provider.QueryLookupAsync(f, q, 0, 10);
                _lookupResults[f] = list.ToList();
                _openLookupField = f;
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine(ex);
        }
    }

    private async Task OnSelectLookupAsync(CardField f, Guid id, string name)
    {
        // set selected id and display name
        f.ValueId = id;
        f.Text = name;
        // remember pending lookup (store LookupItem with key+name) in ViewModel
        if (Provider is not null) Provider.ValidateLookupField(f, new LookupItem(id, name));
        _lookupResults.Remove(f);
        if (_openLookupField == f) _openLookupField = null;
        // ask ViewModel to reload in case other fields depend on selection
        await (Provider?.ReloadAsync() ?? Task.CompletedTask);
        await InvokeAsync(StateHasChanged);
    }

    private void CloseLookup(CardField f)
    {
        // hide overlay for this field
        if (_openLookupField == f) _openLookupField = null;
        _lookupResults.Remove(f);
        _ = InvokeAsync(StateHasChanged);
    }

    private void OnLookupChangeCommit(CardField f, ChangeEventArgs e)
    {
        // when user leaves input without selecting, treat current text as pending new name (no id)
        var txt = (e.Value ?? string.Empty).ToString();
        if (Provider is null) return;
        // If a LookupItem is already stored as pending (selection happened), don't overwrite with the raw text
        if (Provider.PendingFieldValues.TryGetValue(f.LabelKey, out var existing) && existing is LookupItem)
        {
            return;
        }
        Provider.ValidateFieldValue(f, txt);
    }

    private void OnEditableTextChanged(CardField f, ChangeEventArgs e)
    {
        var txt = (e.Value ?? string.Empty).ToString();
        f.Text = txt;
        if (Provider is not null) Provider.ValidateFieldValue(f, txt);
    }

    private void OnEditableCurrencyChanged(CardField f, ChangeEventArgs e)
    {
        var txt = (e.Value ?? string.Empty).ToString();
        if (decimal.TryParse(txt, out var val))
        {
            f.Amount = val;
            if (Provider is not null) Provider.ValidateFieldValue(f, val);
        }
    }

    private void OnEnumChanged(CardField f, ChangeEventArgs e)
    {
        var txt = (e.Value ?? string.Empty).ToString();
        f.Text = txt;
        if (Provider is not null) Provider.ValidateFieldValue(f, txt);
    }
}

