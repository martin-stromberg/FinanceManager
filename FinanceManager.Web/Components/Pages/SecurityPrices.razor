@page "/securities/{SecurityId:guid}/prices"
@rendermode InteractiveServer
@inject HttpClient Http
@inject NavigationManager Nav
@inject IJSRuntime JS
@using System.Net.Http.Json
@using FinanceManager.Shared.Dtos
@using FinanceManager.Web.Components.Shared
@using FinanceManager.Web.ViewModels
@using FinanceManager.Web.ViewModels.Securities
@using Microsoft.Extensions.DependencyInjection
@using Microsoft.Extensions.Localization
n
@using Microsoft.Extensions.Localization
@inject IServiceProvider Services
@inject IStringLocalizer<Components.Pages.SecurityPrices> Localizer
<PageTitle>@Localizer["PageTitle"]</PageTitle>

<Ribbon TTabEnum="SecurityPrices.TabId" Tabs="_tabs" ActiveTab="_activeTab" ActiveTabChanged="OnActiveTabChanged" />

<h3>@Localizer["Title"]</h3>

<BackgroundTaskStatusPanel AllowedTypes="new[]{ BackgroundTaskType.SecurityPricesBackfill }" />

@if (_vm?.ShowBackfillDialog == true)
{
    <div class="modal-overlay" @onclick="(()=> _vm!.ShowBackfillDialog = false)">
        <div class="modal" @onclick:stopPropagation="true">
            <h3 class="modal-title">@Localizer["Dlg_Backfill_Title"]</h3>
            <div class="row">
                <label>@Localizer["Dlg_From"]</label>
                <input type="date"
                       @bind-value="_vm!.FromDate"
                       @bind-value:event="onchange" />
            </div>
            <div class="row">
                <label>@Localizer["Dlg_To"]</label>
                <input type="date" @bind-value="_vm!.ToDate" @bind-value:event="onchange" />
            </div>
            @if (!string.IsNullOrWhiteSpace(_vm?.DialogErrorKey))
            {
                <div class="dialog-error">@Localizer[_vm.DialogErrorKey!]</div>
            }
            <div class="dialog-actions">
                <button class="btn" disabled="@(_vm?.Submitting ?? false)" @onclick="async () => await _vm!.ConfirmBackfillAsync()">
                    @((_vm?.Submitting ?? false) ? Localizer["Dlg_Starting"] : Localizer["Dlg_Start"])
                </button>
                <button class="btn secondary" disabled="@(_vm?.Submitting ?? false)" @onclick="(()=> _vm!.CloseBackfillDialog())">@Localizer["Dialog_Cancel"]</button>
            </div>
        </div>
    </div>
}

@if((_vm?.Loading ?? true) && (_vm?.Items.Count ?? 0) == 0)
{
    <p>@Localizer["Loading"]</p>
}
else
{
    <table class="fm-table wide">
        <thead>
            <tr>
                <th class="col-date">@Localizer["Th_Date"]</th>
                <th class="col-close">@Localizer["Th_Close"]</th>
            </tr>
        </thead>
        <tbody>
            @if(_vm is not null)
            {
                @foreach(var p in _vm.Items)
                {
                    <tr>
                        <td>@p.Date.ToShortDateString()</td>
                        <td class="amount-cell">@p.Close</td>
                    </tr>
                }
            }
            @if(_vm?.Loading == true)
            {
                <tr><td colspan="2" class="loading-cell">@Localizer["Loading"]</td></tr>
            }
        </tbody>
    </table>
    <div class="table-footer">
        @if(_vm?.CanLoadMore == true)
        {
            <div @ref="_sentinel" class="infinite-sentinel" aria-hidden="true"></div>
        }
        else if((_vm?.Items.Count ?? 0)==0 && _vm?.Loading == false)
        {
            <span class="no-entries">@Localizer["NoEntries"]</span>
        }
        else if(_vm?.CanLoadMore == false)
        {
            <div class="end-of-list">@Localizer["EndOfList"]</div>
        }
    </div>
}

@code {
    [Parameter] public Guid SecurityId { get; set; }

    // Infinite scroll
    private ElementReference _sentinel;
    private DotNetObjectReference<SecurityPrices>? _selfRef;
    private bool _observerAttached;

    // Ribbon
    private enum TabId { Prices }
    private List<Ribbon<TabId>.RibbonTab<TabId>> _tabs = new();
    private TabId _activeTab = TabId.Prices;
    private Task OnActiveTabChanged(TabId id){ _activeTab = id; return Task.CompletedTask; }

    // ViewModel
    private SecurityPricesViewModel? _vm;

    protected override async Task OnParametersSetAsync()
    {
        if (_vm == null || _vm.SecurityId != SecurityId)
        {
            if (_vm is not null)
            {
                _vm.StateChanged -= VmOnStateChanged;
                await _vm.DisposeAsync();
            }
            _vm = ActivatorUtilities.CreateInstance<SecurityPricesViewModel>(Services);
            _vm.StateChanged += VmOnStateChanged;
            _vm.ForSecurity(SecurityId);
            await _vm.InitializeAsync();
            RebuildRibbon();
        }
    }

    private void VmOnStateChanged(object? sender, EventArgs e)
    {
        RebuildRibbon();
        _ = InvokeAsync(StateHasChanged);
    }

    private void RebuildRibbon()
    {
        var groupsDto = _vm?.GetRibbon(Localizer) ?? new List<UiRibbonGroup>();
        var groups = new List<Ribbon<TabId>.RibbonGroup>();
        foreach (var g in groupsDto)
        {
            var items = new List<Ribbon<TabId>.RibbonItem>();
            foreach (var it in g.Items)
            {
                var size = it.Size == UiRibbonItemSize.Large
                    ? Ribbon<TabId>.RibbonItemSize.Large
                    : Ribbon<TabId>.RibbonItemSize.Small;

                items.Add(new Ribbon<TabId>.RibbonItem
                {
                    Label = it.Label,
                    IconSvg = it.IconSvg,
                    Size = size,
                    Disabled = it.Disabled,
                    Callback = () => { HandleRibbonAction(it.Action); return Task.CompletedTask; }
                });
            }
            groups.Add(new Ribbon<TabId>.RibbonGroup { Title = g.Title, Items = items });
        }

        _tabs = new()
        {
            new Ribbon<TabId>.RibbonTab<TabId>
            {
                Id = TabId.Prices,
                Title = Localizer["Ribbon_Tab_Prices"],
                Groups = groups
            }
        };
        StateHasChanged();
    }

    private void HandleRibbonAction(string action)
    {
        switch (action)
        {
            case "Back":
                Nav.NavigateTo($"/securities/{SecurityId}");
                break;
            case "Backfill":
                _vm?.OpenBackfillDialogDefaultPeriod();
                break;
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_vm is not null)
        {
            _vm.StateChanged -= VmOnStateChanged;
            await _vm.DisposeAsync();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_observerAttached || !(_vm?.CanLoadMore ?? false) || (_vm?.Loading ?? true))
        {
            return;
        }
        if (_sentinel.Context is null)
        {
            return;
        }
        try
        {
            _selfRef ??= DotNetObjectReference.Create(this);
            await JS.InvokeVoidAsync("fmInfinite.observe", _sentinel, _selfRef, null);
            _observerAttached = true;
        }
        catch (JSException)
        {
            await Task.Yield();
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task LoadMoreFromJs()
    {
        if (_vm is null) { return; }
        await _vm.LoadMoreAsync();
        if (_vm.CanLoadMore)
        {
            await JS.InvokeVoidAsync("fmInfinite.refresh");
        }
        else
        {
            StateHasChanged();
        }
    }
}
