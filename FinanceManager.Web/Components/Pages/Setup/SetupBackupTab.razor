@using System.Net.Http.Json
@using FinanceManager.Web.ViewModels.Setup
@inject Microsoft.Extensions.Localization.IStringLocalizer<Pages> Localizer
@inject IJSRuntime JS
@using FinanceManager.Web.ViewModels
@using Microsoft.Extensions.DependencyInjection

<div>
    <h4 style="margin-top:0;">@Localizer["SetupBackup_Titel"]</h4>

    @* Ribbon supplies actions; keep a hidden fallback input for upload *@
    <div style="display:none;">
        <InputFile id="backupFileInput" OnChange="OnBackupUploadSelected" />
        <button @onclick="(()=> _vm?.CreateAsync())">create fallback</button>
    </div>

    @if (!string.IsNullOrWhiteSpace(_vm?.LastError))
    {
        <div class="error" style="margin-top:.5rem;">@_vm!.LastError</div>
    }

    <div class="table-responsive" style="margin-top:.75rem;">
        <table class="fm-table">
            <thead>
                <tr>
                    <th style="width:11rem;">@Localizer["SetupBackup_Th_Created"]</th>
                    <th>@Localizer["SetupBackup_Th_File"]</th>
                    <th style="width:6rem;">@Localizer["SetupBackup_Th_Size"]</th>
                    <th style="width:6rem;">@Localizer["SetupBackup_Th_Source"]</th>
                    <th style="width:1%;white-space:nowrap;">@Localizer["SetupBackup_Th_Actions"]</th>
                </tr>
            </thead>
            <tbody>
                @if (_vm!.Backups == null)
                {
                    <tr><td colspan="5">@Localizer["Msg_Loading"]</td></tr>
                }
                else if (_vm!.Backups.Count == 0)
                {
                    <tr><td colspan="5">@Localizer["Msg_NoBackups"]</td></tr>
                }
                else
                {
                    @foreach (var b in _vm!.Backups)
                    {
                        <tr @onclick="() => SelectBackup(b.Id)" class="@(_selectedBackupId==b.Id?"selected-row":null)">
                            <td>@b.CreatedUtc.ToLocalTime().ToString("g")</td>
                            <td>@b.FileName</td>
                            <td>@FormatSize(b.SizeBytes)</td>
                            <td>@b.Source</td>
                            <td style="white-space:nowrap;display:flex;gap:.25rem;">
                                <button class="icon-btn" title="@Localizer["Ribbon_Restore"]" disabled="@(_vm!.Busy || _vm!.HasActiveRestore)" @onclick:stopPropagation @onclick="() => StartApplyBackgroundAsync(b.Id)">
                                    <svg class="icon"><use href="icons/sprite.svg#restore" /></svg>
                                </button>
                                <a class="icon-btn" title="@Localizer["Ribbon_Download"]" href="@($"/api/setup/backups/{b.Id}/download")" download @onclick:stopPropagation>
                                    <svg class="icon"><use href="icons/sprite.svg#download" /></svg>
                                </a>
                                <button class="icon-btn danger" title="@Localizer["Ribbon_Delete"]" @onclick:stopPropagation @onclick="() => DeleteBackupAsync(b.Id)" disabled="@_vm!.Busy">
                                    <svg class="icon"><use href="icons/sprite.svg#delete" /></svg>
                                </button>
                            </td>
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>
</div>

@code {
    [Parameter] public SetupBackupsViewModel? ViewModel { get; set; }

    private SetupBackupsViewModel? _vm;
    private Guid? _selectedBackupId;
    private IBrowserFile? _uploadFile;
    private EventHandler? _stateChangedHandler;

    protected override async Task OnInitializedAsync()
    {
        _vm = ViewModel ?? throw new InvalidOperationException("ViewModel parameter is required for SetupBackupTab.");
        _stateChangedHandler = (_, __) => { _ = InvokeAsync(StateHasChanged); };
        _vm.StateChanged += _stateChangedHandler;

        _vm.UploadRequested += OnUploadRequested;

        await _vm.LoadBackupsAsync();
    }

    public void Dispose()
    {
        if (_vm is not null)
        {
            if (_stateChangedHandler is not null) _vm.StateChanged -= _stateChangedHandler;
            _vm.UploadRequested -= OnUploadRequested;
        }
    }

    private void SelectBackup(Guid id)
    {
        _selectedBackupId = _selectedBackupId == id ? (Guid?)null : id;
    }

    private async Task StartApplyBackgroundAsync(Guid id)
    {
        if (id == Guid.Empty) return;
        await _vm!.StartApplyAsync(id);
    }

    private async Task DeleteBackupAsync(Guid id)
    {
        await _vm!.DeleteAsync(id);
        if (_selectedBackupId == id) _selectedBackupId = null;
    }

    private void OnBackupUploadSelected(InputFileChangeEventArgs e)
    {
        _uploadFile = e.File;
        _ = UploadBackupAsync();
    }

    private async Task UploadBackupAsync()
    {
        if (_uploadFile == null) return;
        await using var stream = _uploadFile.OpenReadStream(1024L * 1024L * 1024L);
        await _vm!.UploadAsync(stream, _uploadFile.Name);
    }

    private async void OnUploadRequested(object? sender, EventArgs e)
    {
        try
        {
            await JS.InvokeVoidAsync("financeManager.clickElementById", "backupFileInput");
        }
        catch { }
    }

    private static string FormatSize(long bytes)
    {
        string[] units = new[] { "B", "KB", "MB", "GB" };
        double size = bytes; int unit = 0;
        while (size >= 1024 && unit < units.Length - 1) { size /= 1024; unit++; }
        return $"{size:N1} {units[unit]}";
    }
}
